// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

using k8s;
using k8s.Autorest;
using k8s.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.Kubernetes.Client;

public class AnyResourceKind : IAnyResourceKind
{
    public AnyResourceKind(IKubernetes kubernetes)
    {
        Client = (k8s.Kubernetes)kubernetes;
    }

    public k8s.Kubernetes Client { get; }

    private static string Pattern(string group, string ns)
    {
        if (string.IsNullOrEmpty(group))
        {
            return string.IsNullOrEmpty(ns)
                ? "api/{version}/{plural}"
                : "api/{version}/namespaces/{namespace}/{plural}";
        }

        return string.IsNullOrEmpty(ns)
            ? "apis/{group}/{version}/{plural}"
            : "apis/{group}/{version}/namespaces/{namespace}/{plural}";
    }

    public async Task<HttpOperationResponse<object>> CreateAnyResourceKindWithHttpMessagesAsync<TResource>(
        TResource body,
        string group, string version, string namespaceParameter, string plural, string dryRun = null,
        string fieldManager = null, string pretty = null,
        IReadOnlyDictionary<string, IReadOnlyList<string>> customHeaders = null,
        CancellationToken cancellationToken = default) where TResource : IKubernetesObject
    {

        if (body is null)
        {
            throw new ArgumentNullException();
        }

        if (group is null)
        {
            throw new ArgumentNullException();
        }

        if (version is null)
        {
            throw new ArgumentNullException();
        }

        if (namespaceParameter is null)
        {
            throw new ArgumentNullException();
        }

        if (plural is null)
        {
            throw new ArgumentNullException();
        }

        var url = Pattern(group, namespaceParameter);
        url = url.Replace("{group}", Uri.EscapeDataString(group));
        url = url.Replace("{version}", Uri.EscapeDataString(version));
        url = url.Replace("{namespace}", Uri.EscapeDataString(namespaceParameter));
        url = url.Replace("{plural}", Uri.EscapeDataString(plural));
        var queryParameters = new List<string>();
        if (dryRun is not null)
        {
            queryParameters.Add($"dryRun={Uri.EscapeDataString(dryRun)}");
        }

        if (fieldManager is not null)
        {
            queryParameters.Add($"fieldManager={Uri.EscapeDataString(fieldManager)}");
        }

        if (pretty is not null)
        {
            queryParameters.Add($"pretty={Uri.EscapeDataString(pretty)}");
        }

        if (queryParameters.Count > 0)
        {
            url += "?" + string.Join("&", queryParameters);
        }


        var httpRequest = CreateRequest(url, HttpMethod.Post, customHeaders);
        var httpResponse = await SendRequestRaw(KubernetesJson.Serialize(body), httpRequest, cancellationToken);
        // Create Result
        var result = await CreateResultAsync<object>(httpRequest, httpResponse, null, cancellationToken);
        return result;
    }

    public async Task<HttpOperationResponse<object>> DeleteAnyResourceKindWithHttpMessagesAsync(string group,
        string version,
        string namespaceParameter, string plural, string name, V1DeleteOptions body = null,
        int? gracePeriodSeconds = null, bool? orphanDependents = null, string propagationPolicy = null,
        string dryRun = null, IReadOnlyDictionary<string, IReadOnlyList<string>> customHeaders = null,
        CancellationToken cancellationToken = default)
    {
        if (group is null)
        {
            throw new ArgumentNullException();
        }

        if (version is null)
        {
            throw new ArgumentNullException();
        }

        if (namespaceParameter is null)
        {
            throw new ArgumentNullException();
        }

        if (plural is null)
        {
            throw new ArgumentNullException();
        }

        if (name is null)
        {
            throw new ArgumentNullException();
        }

        var url = Pattern(group, namespaceParameter) + "/{name}";
        url = url.Replace("{group}", Uri.EscapeDataString(group));
        url = url.Replace("{version}", Uri.EscapeDataString(version));
        url = url.Replace("{namespace}", Uri.EscapeDataString(namespaceParameter));
        url = url.Replace("{plural}", Uri.EscapeDataString(plural));
        url = url.Replace("{name}", Uri.EscapeDataString(name));
        var queryParameters = new List<string>();
        if (gracePeriodSeconds is not null)
        {
            queryParameters.Add(
                $"gracePeriodSeconds={Uri.EscapeDataString(JsonConvert.SerializeObject(gracePeriodSeconds).Trim('"'))}");
        }

        if (orphanDependents is not null)
        {
            queryParameters.Add(
                $"orphanDependents={Uri.EscapeDataString(JsonConvert.SerializeObject(orphanDependents).Trim('"'))}");
        }

        if (propagationPolicy is not null)
        {
            queryParameters.Add($"propagationPolicy={Uri.EscapeDataString(propagationPolicy)}");
        }

        if (dryRun is not null)
        {
            queryParameters.Add($"dryRun={Uri.EscapeDataString(dryRun)}");
        }

        if (queryParameters.Count > 0)
        {
            url += "?" + string.Join("&", queryParameters);
        }

        var httpRequest = CreateRequest(url, HttpMethod.Delete, customHeaders);
        var httpResponse = await SendRequestRaw(string.Empty, httpRequest, cancellationToken);
        // Create Result
        var result = await CreateResultAsync<object>(httpRequest, httpResponse, null, cancellationToken);
        return result;
    }

    public async Task<HttpOperationResponse<KubernetesList<TResource>>>
        ListClusterAnyResourceKindWithHttpMessagesAsync<TResource>(
            string group,
            string version,
            string plural,
            string continueParameter = null,
            string fieldSelector = null,
            string labelSelector = null,
            int? limit = null,
            string resourceVersion = null,
            int? timeoutSeconds = null,
            bool? watch = null,
            string pretty = null,
            IReadOnlyDictionary<string, IReadOnlyList<string>> customHeaders = null,
            CancellationToken cancellationToken = default) where TResource : IKubernetesObject
    {

        if (group is null)
        {
            throw new ArgumentNullException();
        }

        if (version is null)
        {
            throw new ArgumentNullException();
        }

        if (plural is null)
        {
            throw new ArgumentNullException();
        }

        var namespaces = Client.ListNamespace();

        var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        cts.CancelAfter(Client.HttpClientTimeout);

        if (watch == true)
        {
            cts.CancelAfter(Timeout.InfiniteTimeSpan);
        }

        cancellationToken = cts.Token;

        var url = "apis/{group}/{version}/{plural}";
        url = string.IsNullOrEmpty(group)
            ? url.Replace("apis/{group}", "api")
            : url.Replace("{group}", Uri.EscapeDataString(group));
        url = url.Replace("{version}", Uri.EscapeDataString(version));
        url = url.Replace("{plural}", Uri.EscapeDataString(plural));

        List<string> queryParameters = new List<string>();
        if (continueParameter is not null)
        {
            queryParameters.Add($"continue={Uri.EscapeDataString(continueParameter)}");
        }

        if (fieldSelector is not null)
        {
            queryParameters.Add($"fieldSelector={Uri.EscapeDataString(fieldSelector)}");
        }

        if (labelSelector is not null)
        {
            queryParameters.Add($"labelSelector={Uri.EscapeDataString(labelSelector)}");
        }

        if (limit is not null)
        {
            queryParameters.Add($"limit={Uri.EscapeDataString(JsonConvert.SerializeObject(limit).Trim('"'))}");
        }

        if (resourceVersion is not null)
        {
            queryParameters.Add($"resourceVersion={Uri.EscapeDataString(resourceVersion)}");
        }

        if (timeoutSeconds is not null)
        {
            queryParameters.Add(
                $"timeoutSeconds={Uri.EscapeDataString(JsonConvert.SerializeObject(timeoutSeconds).Trim('"'))}");
        }

        if (watch is not null)
        {
            queryParameters.Add($"watch={Uri.EscapeDataString(JsonConvert.SerializeObject(watch).Trim('"'))}");
        }

        if (pretty is not null)
        {
            queryParameters.Add($"pretty={Uri.EscapeDataString(pretty)}");
        }

        if (queryParameters.Count > 0)
        {
            url += "?" + string.Join("&", queryParameters);
        }

        // Create HTTP transport
        var httpRequest = CreateRequest(url, HttpMethod.Get, customHeaders);
        var httpResponse = await SendRequestRaw(string.Empty, httpRequest, cancellationToken);
        // Create Result
        var result = await CreateResultAsync<KubernetesList<TResource>>(httpRequest,
            httpResponse,
            watch,
            cancellationToken);
        return result;
    }

    public async Task<HttpOperationResponse<object>> PatchAnyResourceKindWithHttpMessagesAsync(V1Patch body,
        string group,
        string version, string namespaceParameter, string plural, string name, string dryRun = null,
        string fieldManager = null, bool? force = null,
        IReadOnlyDictionary<string, IReadOnlyList<string>> customHeaders = null,
        CancellationToken cancellationToken = default)
    {
        if (body is null)
        {
            throw new ArgumentNullException();
        }

        if (group is null)
        {
            throw new ArgumentNullException();
        }

        if (version is null)
        {
            throw new ArgumentNullException();
        }

        if (plural is null)
        {
            throw new ArgumentNullException();
        }

        if (name is null)
        {
            throw new ArgumentNullException();
        }

        var url = Pattern(group, namespaceParameter) + "/{name}";
        url = url.Replace("{group}", Uri.EscapeDataString(group));
        url = url.Replace("{version}", Uri.EscapeDataString(version));
        url = url.Replace("{plural}", Uri.EscapeDataString(plural));
        url = url.Replace("{name}", Uri.EscapeDataString(name));
        List<string> queryParameters = new();
        if (dryRun is not null)
        {
            queryParameters.Add($"dryRun={Uri.EscapeDataString(dryRun)}");
        }

        if (fieldManager is not null)
        {
            queryParameters.Add($"fieldManager={Uri.EscapeDataString(fieldManager)}");
        }

        if (force is not null)
        {
            queryParameters.Add($"force={Uri.EscapeDataString(JsonConvert.SerializeObject(force).Trim('"'))}");
        }

        if (queryParameters.Count > 0)
        {
            url += "?" + string.Join("&", queryParameters);
        }

        var httpRequest = CreateRequest(url, HttpMethod.Patch, customHeaders);
        var httpResponse = await SendRequest(body, httpRequest, cancellationToken);
        // Create Result
        var result = await CreateResultAsync<object>(httpRequest, httpResponse, null, cancellationToken);
        return result;
    }

    private HttpRequestMessage CreateRequest(string relativeUri, HttpMethod method,
        IReadOnlyDictionary<string, IReadOnlyList<string>> customHeaders)
    {
        var httpRequest = new HttpRequestMessage();
        httpRequest.Method = method;
        httpRequest.RequestUri = new Uri(Client.BaseUri, relativeUri);
        if (customHeaders != null)
        {
            foreach (var header in customHeaders)
            {
                httpRequest.Headers.Remove(header.Key);
                httpRequest.Headers.TryAddWithoutValidation(header.Key, header.Value);
            }
        }

        return httpRequest;
    }

    private Task<HttpResponseMessage> SendRequest<T>(T body, HttpRequestMessage httpRequest,
        CancellationToken cancellationToken)
    {
        if (body != null)
        {
            var requestContent = KubernetesJson.Serialize(body);
            httpRequest.Content = new StringContent(requestContent, System.Text.Encoding.UTF8);
            httpRequest.Content.Headers.ContentType = GetHeader(body);
            return SendRequestRaw(requestContent, httpRequest, cancellationToken);
        }

        return SendRequestRaw("", httpRequest, cancellationToken);
    }

    private async Task<HttpResponseMessage> SendRequestRaw(string requestContent, HttpRequestMessage httpRequest,
        CancellationToken cancellationToken)
    {
        if (httpRequest == null)
        {
            throw new ArgumentNullException(nameof(httpRequest));
        }

        if (Client.Credentials is not null)
        {
            cancellationToken.ThrowIfCancellationRequested();
            await Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
        }

        // Send Request
        cancellationToken.ThrowIfCancellationRequested();
        var httpResponse = await Client.HttpClient
            .SendAsync(httpRequest, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
        var statusCode = httpResponse.StatusCode;
        cancellationToken.ThrowIfCancellationRequested();

        if (!httpResponse.IsSuccessStatusCode)
        {
            string responseContent = null;
            var ex = new HttpOperationException($"Operation returned an invalid status code '{statusCode}'");
            if (httpResponse.Content != null)
            {
                responseContent = await httpResponse.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
            }

            ex.Request = new HttpRequestMessageWrapper(httpRequest, requestContent);
            ex.Response = new HttpResponseMessageWrapper(httpResponse, responseContent);
            httpRequest.Dispose();
            if (httpResponse != null)
            {
                httpResponse.Dispose();
            }

            throw ex;
        }

        return httpResponse;
    }

    async Task<HttpOperationResponse<T>> CreateResultAsync<T>(HttpRequestMessage httpRequest,
        HttpResponseMessage httpResponse, bool? watch, CancellationToken cancellationToken)
    {
        if (httpRequest == null)
        {
            throw new ArgumentNullException(nameof(httpRequest));
        }

        if (httpResponse == null)
        {
            throw new ArgumentNullException(nameof(httpResponse));
        }

        var result = new HttpOperationResponse<T> { Request = httpRequest, Response = httpResponse };

        if (watch == true)
        {
            httpResponse.Content = new LineSeparatedHttpContent(httpResponse.Content, cancellationToken);
        }

        try
        {
            await using var stream =
                await httpResponse.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
            result.Body = KubernetesJson.Deserialize<T>(stream);
        }
        catch (JsonException)
        {
            httpRequest.Dispose();
            httpResponse.Dispose();
            throw;
        }

        return result;
    }

    private MediaTypeHeaderValue GetHeader(object body)
    {
        if (body == null)
        {
            throw new ArgumentNullException(nameof(body));
        }

        if (body is V1Patch patch)
        {
            return GetHeader(patch);
        }

        return MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
    }

    private MediaTypeHeaderValue GetHeader(V1Patch body)
    {
        if (body == null)
        {
            throw new ArgumentNullException(nameof(body));
        }

        switch (body.Type)
        {
            case V1Patch.PatchType.JsonPatch:
                return MediaTypeHeaderValue.Parse("application/json-patch+json; charset=utf-8");
            case V1Patch.PatchType.MergePatch:
                return MediaTypeHeaderValue.Parse("application/merge-patch+json; charset=utf-8");
            case V1Patch.PatchType.StrategicMergePatch:
                return MediaTypeHeaderValue.Parse("application/strategic-merge-patch+json; charset=utf-8");
            case V1Patch.PatchType.ApplyPatch:
                return MediaTypeHeaderValue.Parse("application/apply-patch+yaml; charset=utf-8");
            case V1Patch.PatchType.Unknown:
            default:
                throw new ArgumentOutOfRangeException(nameof(body.Type), "");
        }
    }
}
